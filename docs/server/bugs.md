# Server Bugs Analysis

Document generated by automated code analysis.

---

## Bug #1: Race Condition in First User Admin Assignment

**File:** `server/src/routes/auth.ts`
**Lines:** 43-56
**Severity:** Medium

**Description:**
Between `countDocuments()` and `save()`, a race condition exists where multiple concurrent registrations could result in multiple admin users being created.

```typescript
const userCount = await User.countDocuments();
const isFirstUser = userCount === 0;
// ... other code ...
const user = new User({
  // ...
  isAdmin: isFirstUser,  // Race condition here
});
await user.save();
```

**Suggestion:**
Use MongoDB transaction or `findOneAndUpdate` with upsert to atomically check and set the first admin.

---

## Bug #2: Missing Room Membership Verification in Mark Read

**File:** `server/src/routes/messages.ts`
**Lines:** 131-168
**Severity:** Medium

**Description:**
The `PATCH /messages/:id/read` endpoint doesn't verify the user is a member of the room before marking messages as read. Any authenticated user can mark any message as read.

```typescript
router.patch('/:id/read', async (req: AuthRequest, res: Response) => {
  const message = await Message.findById(req.params.id);
  // No room membership check!
  if (!message.readBy.some(id => id.toString() === req.userId)) {
    message.readBy.push(req.userId as any);
```

**Suggestion:**
Add room membership verification before allowing the operation.

---

## Bug #3: Missing Room Membership Verification in Bulk Read

**File:** `server/src/routes/messages.ts`
**Lines:** 233-269
**Severity:** Medium

**Description:**
The `POST /messages/read-bulk` endpoint updates read status for messages without verifying the user has access to those messages or their rooms.

```typescript
await Message.updateMany(
  {
    _id: { $in: messageIds },
    senderId: { $ne: req.userId },
  },
  { $addToSet: { readBy: req.userId } }
);
// No verification that user has access to these messages
```

**Suggestion:**
Filter messageIds to only include messages from rooms the user is a member of.

---

## Bug #4: Information Disclosure in Login Error Messages

**File:** `server/src/routes/auth.ts`
**Lines:** 89-102
**Severity:** Low

**Description:**
Different error messages for "user not found" vs "wrong password" allow username enumeration attacks.

```typescript
if (!user) {
  res.status(401).json({ error: 'Utilisateur non trouvÃ©' });  // Reveals user doesn't exist
  return;
}
// ...
if (!isValidPassword) {
  res.status(401).json({ error: 'Mot de passe incorrect' });  // Reveals user exists
```

**Suggestion:**
Use a generic error message like "Invalid credentials" for both cases.

---

## Bug #5: Missing Room Membership Verification in React to Message

**File:** `server/src/routes/messages.ts`
**Lines:** 175-230
**Severity:** Medium

**Description:**
The `POST /messages/:id/react` endpoint doesn't verify the user is a member of the room before allowing reactions on messages.

**Suggestion:**
Add room membership verification before allowing the operation.

---

## Bug #6: Socket Room Join Without Authorization

**File:** `server/src/socket/index.ts`
**Lines:** 148-155
**Severity:** High

**Description:**
The `room:join` socket event allows any authenticated user to join any room's socket channel without verifying membership.

```typescript
socket.on('room:join', async (data: { roomId: string }) => {
  socket.join(`room:${data.roomId}`);  // No verification!
  socket.to(`room:${data.roomId}`).emit('user:joined-room', {
```

**Suggestion:**
Verify room membership before allowing socket room join.

---

## Bug #7: WebRTC Signaling Without Relationship Verification

**File:** `server/src/socket/index.ts`
**Lines:** 230-259
**Severity:** Medium

**Description:**
WebRTC signaling events (offer, answer, ice-candidate) are relayed to any user without verifying the sender has any relationship (common room, contact) with the target.

```typescript
socket.on('webrtc:offer', (data: { to: string; offer: unknown }) => {
  io.to(`user:${data.to}`).emit('webrtc:offer', {  // No verification!
```

**Suggestion:**
Verify users share a common room or are contacts before relaying WebRTC signals.

---

## Bug #8: Call Request Without Relationship Verification

**File:** `server/src/socket/index.ts`
**Lines:** 264-292
**Severity:** Medium

**Description:**
Call signaling events are relayed without verifying the relationship between users, allowing any user to initiate calls to any other user.

**Suggestion:**
Verify users share a common room or are contacts before relaying call signals.

---

## Bug #9: Rate Limit Map Memory Leak

**File:** `server/src/mcp/auth.ts`
**Lines:** 10-11
**Severity:** Low

**Description:**
The `rateLimitMap` is never cleaned up. Old entries accumulate indefinitely, causing memory growth over time.

```typescript
const rateLimitMap = new Map<string, { count: number; resetAt: number }>();
// Never cleaned up
```

**Suggestion:**
Implement periodic cleanup of expired rate limit entries, or use a TTL-based cache.

---

## Bug #10: Stale Room List on Disconnect

**File:** `server/src/socket/index.ts`
**Lines:** 345-348
**Severity:** Low

**Description:**
On disconnect, the `userRooms` variable references the room list captured at connection time. If the user joined/left rooms during the session, the offline notification is sent to the wrong rooms.

```typescript
socket.on('disconnect', async () => {
  // userRooms is from connection time, may be stale
  userRooms.forEach(room => {
    socket.to(`room:${room._id}`).emit('user:offline', { userId, roomId: room._id });
```

**Suggestion:**
Query current room membership on disconnect, or maintain a live room list.

---

## Bug #11: Missing Input Validation in Socket Events

**File:** `server/src/socket/index.ts`
**Lines:** Various
**Severity:** Medium

**Description:**
Socket event handlers don't validate input data types or format before processing. Malformed data could cause crashes or unexpected behavior.

```typescript
socket.on('typing:start', (data: { roomId: string }) => {
  // No validation that data is an object or roomId is a string
  socket.to(`room:${data.roomId}`).emit('typing:start', ...);
```

**Suggestion:**
Add input validation (e.g., with zod) for all socket event handlers.

---

## Bug #12: Notes Accessible to All Authenticated Users

**File:** `server/src/routes/notes.ts`
**Lines:** 77-100, 259-281
**Severity:** Medium

**Description:**
Notes have no ownership verification. Any authenticated user can read, modify, or delete any note. The `createdBy` field exists but is not used for authorization.

```typescript
// GET /notes - no user filter
const notes = await Note.find(filter).sort({ isPinned: -1, order: 1 });

// DELETE /notes/:id - no owner check
await Note.findByIdAndDelete(req.params.id);
```

**Suggestion:**
Add authorization checks to verify the user is the creator or has permission to access the note.

---

## Bug #13: File Upload Missing Room lastMessageAt Update

**File:** `server/src/routes/upload.ts`
**Lines:** 239-300
**Severity:** Low

**Description:**
The file upload endpoint (`POST /upload/file`) doesn't update the room's `lastMessageAt` field, causing the room to not sort correctly in the room list.

Compare with image upload (line 214) which correctly updates it:
```typescript
// Image upload - correct
await Room.findByIdAndUpdate(roomId, { lastMessageAt: new Date() });

// File upload - missing this update
```

**Suggestion:**
Add `lastMessageAt` update after file message creation.

---

## Bug #14: Potential Path Traversal in File Deletion

**File:** `server/src/routes/files.ts`
**Lines:** 142-153
**Severity:** Low

**Description:**
File path is constructed from `message.content` stored in the database. While the content is server-generated, if database was compromised, this could lead to arbitrary file deletion.

```typescript
const fileUrl = message.content;
if (fileUrl.startsWith('/uploads/')) {
  const filePath = path.join(process.cwd(), 'public', fileUrl);
  // Could delete files outside uploads if fileUrl contains ../
```

**Suggestion:**
Validate the resolved path stays within the uploads directory using `path.resolve()` and checking the prefix.

---

## Bug #15: Location History Accessible Without Authorization

**File:** `server/src/routes/users.ts`
**Lines:** 74-105
**Severity:** High

**Description:**
The `GET /users/:userId/location-history` endpoint allows any authenticated user to view any other user's location history without authorization checks.

```typescript
router.get('/:userId/location-history', async (req: AuthRequest, res: Response) => {
  const { userId } = req.params;
  // No check if requesting user has permission to view this user's location
  const history = await LocationHistory.find({ userId })
```

**Suggestion:**
Add authorization check - only allow user to view their own history, or admins, or users who share a room/are contacts.

---

## Bug #16: Track Data Accessible Without Authorization

**File:** `server/src/routes/users.ts`
**Lines:** 157-192, 196-235
**Severity:** High

**Description:**
Track endpoints (`GET /users/tracks/:trackId`, `GET /users/:userId/track`) allow any authenticated user to view any user's tracking data (GPS coordinates) without authorization.

```typescript
router.get('/tracks/:trackId', async (req: AuthRequest, res: Response) => {
  const track = await Track.findById(trackId).lean();
  // No ownership or permission check!
  res.json({ track: { ... points: track.points ... } });
```

**Suggestion:**
Add authorization checks - verify requesting user is the track owner, an admin, or has explicit permission.

---

## Bug #17: Location Data Broadcast to All Users

**File:** `server/src/routes/users.ts`
**Lines:** 434-443
**Severity:** Medium

**Description:**
Location updates are broadcast to ALL connected users via `io.emit()`, leaking location data to users who shouldn't see it.

```typescript
if (io) {
  io.emit('user:location-updated', {  // Broadcasts to everyone!
    userId: req.userId,
    location: user.location,
  });
}
```

**Suggestion:**
Only emit location updates to users who should see them (same room members, contacts, or those subscribed to locations room).

---

## Bug #18: ReDoS Risk in User Search

**File:** `server/src/routes/users.ts`
**Lines:** 21-33
**Severity:** Low

**Description:**
User-supplied search input is directly used in regex without escaping, potentially allowing ReDoS (Regular Expression Denial of Service) attacks.

```typescript
const users = await User.find({
  $or: [
    { username: { $regex: query, $options: 'i' } },  // Unescaped user input
    { displayName: { $regex: query, $options: 'i' } },
  ],
});
```

**Suggestion:**
Escape special regex characters from user input before using in query, or use MongoDB text search instead.

---

## Bug #19: Labels Accessible to All Authenticated Users

**File:** `server/src/routes/labels.ts`
**Lines:** 20-28, 84-124, 127-154
**Severity:** Medium

**Description:**
Like notes (Bug #12), labels have no ownership verification. Any authenticated user can view, modify, or delete any label created by anyone.

```typescript
// GET /labels - returns all labels, no user filter
const labels = await Label.find().sort({ name: 1 });

// DELETE /labels/:id - no owner check
await Label.findByIdAndDelete(req.params.id);
```

**Suggestion:**
If labels should be per-user, add `createdBy` filter. If shared, add role-based permissions.

---

## Bug #20: Hardcoded Bot Username

**File:** `server/src/mcp/handlers/send-bot-message.ts`
**Lines:** 68
**Severity:** Low

**Description:**
The bot message handler relies on a hardcoded username "testbot" to find the bot user. If the bot is renamed or doesn't exist, the feature silently fails.

```typescript
const botUser = await getUserByUsername('testbot');  // Hardcoded!
if (!botUser) {
  return { content: [{ type: 'text', text: 'Test Bot user not found' }], isError: true };
}
```

Compare with `send-message.ts` which uses `getBotUser()` that queries by `isBot: true`.

**Suggestion:**
Use `getBotUser()` (queries by `isBot: true` flag) instead of hardcoded username.

---

## Bug #21: Brain Routes Missing Admin Check

**File:** `server/src/routes/brain.ts`
**Lines:** 19-162
**Severity:** High

**Description:**
All brain routes (self, goals, facts, live buffer) only require `authMiddleware` but not `adminMiddleware`. Any authenticated user can view and delete AI agent memory data.

```typescript
router.get('/counts', authMiddleware, async (_req: AuthRequest, res: Response) => {
  // No admin check - any user can see brain data
  const [selfItems, goalsItems, facts, liveInfo] = await Promise.all([...]);
});

router.delete('/self/:id', authMiddleware, async (req: AuthRequest, res: Response) => {
  // No admin check - any user can delete self items
  await deleteSelf(id);
});
```

**Suggestion:**
Add `adminMiddleware` to all brain routes to restrict access to admins only.

---

## Bug #22: Agent Routes Missing Admin Check

**File:** `server/src/routes/agent.ts`
**Lines:** 67-124
**Severity:** Medium

**Description:**
Agent routes (`/agent/ask`, `/agent/reset`, `/agent/memory/*`) only require authentication, allowing any user to interact with the AI agent, reset its session, and delete memory items.

```typescript
router.post('/ask', authMiddleware, async (req: AuthRequest, res: Response) => {
  // Any authenticated user can use the agent
});

router.post('/reset', authMiddleware, async (req: AuthRequest, res: Response) => {
  // Any user can reset the agent session
  await agentService.resetSession();
});

router.delete('/memory/:id', authMiddleware, async (req: AuthRequest, res: Response) => {
  // Any user can delete agent memories
  await deleteMemory(id);
});
```

**Suggestion:**
Add `adminMiddleware` for destructive operations (reset, delete). Consider if `/ask` should be public or restricted.

---

## Bug #23: N+1 Query Performance Issue in Message Emit

**File:** `server/src/utils/socketEmit.ts`
**Lines:** 66-80
**Severity:** Low

**Description:**
When emitting a new message, the function queries the database for unread count for EACH room member. For a room with N members, this makes N database queries per message sent.

```typescript
for (const member of room.members) {
  const memberId = member.userId.toString();
  if (memberId !== userId) {
    // One query per member = O(n) queries per message
    const unreadCount = await Message.countDocuments({
      roomId: new Types.ObjectId(roomId),
      senderId: { $ne: new Types.ObjectId(memberId) },
      readBy: { $ne: new Types.ObjectId(memberId) },
    });
```

**Suggestion:**
Use aggregation to calculate all unread counts in a single query, or defer unread count updates to a background process.

---

## Summary

| Severity | Count |
|----------|-------|
| High     | 4     |
| Medium   | 10    |
| Low      | 9     |
| **Total**| **23**|

### Priority Recommendations

1. **Fix immediately (High):**
   - Bug #6 - Socket room join without authorization
   - Bug #15 - Location history accessible without authorization
   - Bug #16 - Track data accessible without authorization
   - Bug #21 - Brain routes missing admin check

2. **Fix soon (Medium):**
   - Bugs #2, #3, #5 - Missing room membership verification in message routes
   - Bugs #7, #8 - WebRTC/Call signaling without relationship verification
   - Bug #11 - Missing input validation in socket events
   - Bug #12 - Notes accessible to all users
   - Bug #17 - Location data broadcast to all users
   - Bug #19 - Labels accessible to all users
   - Bug #22 - Agent routes missing admin check

3. **Fix when convenient (Low):**
   - Bug #1 - Race condition in first user admin
   - Bug #4 - Information disclosure in login errors
   - Bug #9 - Rate limit map memory leak
   - Bug #10 - Stale room list on disconnect
   - Bug #13 - File upload missing lastMessageAt update
   - Bug #14 - Potential path traversal in file deletion
   - Bug #18 - ReDoS risk in user search
   - Bug #20 - Hardcoded bot username
   - Bug #23 - N+1 query performance issue
